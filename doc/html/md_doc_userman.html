<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>libtap++: NAME</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">libtap++
   &#160;<span id="projectnumber">0.2.0</span>
   </div>
   <div id="projectbrief">implement Test Anything Protocol for C++</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">NAME </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>libtap++ - C++ unit tests for the Test Anything Protocol</p>
<h1>SYNOPSIS</h1>
<pre class="fragment">#include &lt;tap++/tap++.h&gt;
#include &lt;string&gt;

using namespace TAP;

int foo(int ronkle = 1) {
  return ronkle;
}

std::string bar() {
  return "a string";
}

int main() {
  plan(4);
  ok(true, "This test passes");
  is(foo(), 1, "foo() should be 1");
  is(bar(), "a string", "bar() should be \"a string\"");

  TODO="Foo is not completely implemented";
  is(foo(2), 5, "foo(2) should be 5");
  TODO="";

  return exit_status();
}
</pre><h1>DESCRIPTION</h1>
<p><code>libtap++</code> is a TAP producer for C++ programs.</p>
<h1>FUNCTIONS</h1>
<p>All functions and variables are defined in the <code>TAP</code> namespace.</p>
<h2>I love it when a plan comes together</h2>
<p>Before anything else, you need a testing plan. This basically declares how many tests your script is going to run to protect against premature failure.</p>
<ul>
<li><p class="startli"><b>plan()</b> </p><pre class="fragment">  void plan(int number_of_tests);
  void plan(skip_all, const std::string&amp; reason="");
  void plan(no_plan);
</pre><p class="startli">The function <code>plan</code> is used to indicate the plan of your test run. Usually you will just give it the number of tests as argument.</p>
<p class="startli">Alternatively, you can give it the <code>skip_all</code> or <code>no_plan</code> constants as arguments. The first means you will not run the tests at all, the second means you will run an unknown number of tests (the latter is not recommended).</p>
</li>
<li><p class="startli"><b><a class="el" href="tap_09_09_8cpp.html#aa5de8e936c67fc8abafef71d7729e83c" title="declare that testing the current group has finished ">done_testing()</a></b> </p><pre class="fragment">  void done_testing();
  void done_testing(int number_of_tests);
</pre><p class="startli">If you don't know how many tests you're going to run, you can issue the plan when you're done running tests.</p>
<p class="startli">number_of_tests is the same as plan(), it's the number of tests you expected to run. You can omit this, in which case the number of tests you ran doesn't matter, just the fact that your tests ran to conclusion.</p>
<p class="startli">This is safer than and replaces the "no\_plan" plan.</p>
</li>
</ul>
<h2>Test names</h2>
<p>By convention, each test is assigned a number in order. This is largely done automatically for you. However, it's often very useful to assign a name to each test. Which would you rather see: </p><pre class="fragment">ok 4
not ok 5
ok 6
</pre><p>or </p><pre class="fragment">ok 4 - basic multi-variable
not ok 5 - simple exponential
ok 6 - force == mass * acceleration
</pre><p>The later gives you some idea of what failed. It also makes it easier to find the test in your script, simply search for "simple
exponential".</p>
<p>All test functions take a name argument. It's optional, but highly suggested that you use it.</p>
<h2>I'm ok, you're not ok.</h2>
<p>The basic purpose of this module is to print out either "ok #" or "not
ok #" depending on if a given test succeeded or failed. Everything else is just gravy.</p>
<p>All of the following print "ok" or "not ok" depending on if the test succeeded or failed. They all also return true or false, respectively.</p>
<ul>
<li><p class="startli"><b><a class="el" href="tap_09_09_8h.html#a2cc8d7b84f20225ecaa111bd1c7f584c" title="primary testing function. uses &#39;condition&#39; to determine  state of the test, which is described by arg...">ok()</a></b> </p><pre class="fragment">  bool ok(bool condition, const std::string&amp; test_name = "");
</pre><p class="startli"><code>ok</code> is the basic test expression in TAP. It simply evaluates any expression, for example, <em>got == expected</em>, taking a true value to mean that the test passed and a false value to mean that the test failed.</p>
<p class="startli"><code>test_name</code> is a very short description of the test that will be printed out. It makes it very easy to find a test in your script when it fails and gives others an idea of your intentions. <code>test_name</code> is optional, but we very strongly encourage its use.</p>
</li>
<li><b>is()</b></li>
<li><p class="startli"><b>isnt()</b> </p><pre class="fragment">  template&lt;typename T, typename U&gt; bool is(const T&amp; got, const U&amp; expected, std::string&amp; test_name = "");
  template&lt;typename T, typename U&gt; bool isnt(const T&amp; got, const U&amp; expected, std::string&amp; test_name = "");
</pre><p class="startli">Similar to <a class="el" href="tap_09_09_8h.html#a2cc8d7b84f20225ecaa111bd1c7f584c" title="primary testing function. uses &#39;condition&#39; to determine  state of the test, which is described by arg...">ok()</a>, is() and isnt() compare their two arguments with <code>==</code> and <code>!=</code> respectively and use the result of that to determine if the test succeeded or failed. So these: </p><pre class="fragment"># Is the ultimate answer 42?
is( ultimate_answer(), 42, "Meaning of Life" );

# foo isn't empty
isnt( foo, "",     "Got some foo" );
</pre><p class="startli">are similar to these: </p><pre class="fragment">ok( ultimate_answer() == 42, "Meaning of Life" );
ok( foo != "", "Got some foo" );
</pre><p class="startli">(Mnemonic: "This is that." "This isn't that.")</p>
<p class="startli">So why use these? They produce better diagnostics on failure. <a class="el" href="tap_09_09_8h.html#a2cc8d7b84f20225ecaa111bd1c7f584c" title="primary testing function. uses &#39;condition&#39; to determine  state of the test, which is described by arg...">ok()</a> cannot know what you are testing for (beyond the name), but is() and isnt() know what the test was and why it failed. For example this test: </p><pre class="fragment">std::string foo("waffle"), bar("yarblokos");
is( foo, bar, 'Is foo the same as bar?' );
</pre><p class="startli">Will produce something like this: </p><pre class="fragment">not ok 17 - Is foo the same as bar?
#   Failed test 'Is foo the same as bar?'
#          got: 'waffle'
#     expected: 'yarblokos'
</pre></li>
<li><b>pass()</b></li>
<li><p class="startli"><b>fail()</b> </p><pre class="fragment">  bool pass(const std::string&amp; test_name = "");
  bool fail(const std::string&amp; test_name = "");
</pre><p class="startli">Sometimes you just want to say that the tests have passed. Usually the case is you've got some complicated condition that is difficult to wedge into an <a class="el" href="tap_09_09_8h.html#a2cc8d7b84f20225ecaa111bd1c7f584c" title="primary testing function. uses &#39;condition&#39; to determine  state of the test, which is described by arg...">ok()</a>. In this case, you can simply use pass() (to declare the test ok) or fail (for not ok). They are synonyms for <a class="el" href="tap_09_09_8h.html#a2cc8d7b84f20225ecaa111bd1c7f584c" title="primary testing function. uses &#39;condition&#39; to determine  state of the test, which is described by arg...">ok(true, test_name)</a> and <a class="el" href="tap_09_09_8h.html#a2cc8d7b84f20225ecaa111bd1c7f584c" title="primary testing function. uses &#39;condition&#39; to determine  state of the test, which is described by arg...">ok(false, test_name)</a>.</p>
<p class="startli">Use these very, very, very sparingly.</p>
</li>
</ul>
<h2>Conditional testing</h2>
<ul>
<li><p class="startli"><b>skip()</b> </p><pre class="fragment">  void skip(int number, const std::string&amp; reason = "");
</pre><p class="startli"><code>skip</code> tells the TAP harness that you're skipping a <em>number</em> of tests for the given <em>reason</em>. Note that you have to do the skipping yourself.</p>
</li>
<li><p class="startli"><b>TODO</b> </p><pre class="fragment">  {
  todo_guard why;
  TODO="why"
  my_tests_here ...
  }
</pre><p class="startli"><code>TODO</code> is a global string variable that tells TAP harness the reason the current test is expected to fail. You set TODO before a block of tests that you expect to fail and then unset it afterwards. When TODO is the empty string, then the harness considers that there is no reason for the test to fail. However, when TODO is non-empty, any failing test is not counted against the test suite and any succeeding test is reported as an unexpected success.</p>
<p class="startli">The nice part about todo tests, as opposed to simply commenting out a block of tests, is it's like having a programmatic todo list. You know how much work is left to be done, you're aware of what bugs there are, and you'll know immediately when they're fixed.</p>
<p class="startli">Note that TODO manipulates a global variable. Thus, you should be careful to set it to "" before going to another section of the program. An easy mistake to make is to have a failing section of code that throws an exception, taking you out of the current scope without resetting TODO. To make it easier to deal with this in a thread-safe manner, the todo_guard class is provided. Objects of this class will reset TODO when they fall out of scope.</p>
</li>
</ul>
<h2>Diagnostics</h2>
<p>If you pick the right test function, you'll usually get a good idea of what went wrong when it failed. But sometimes it doesn't work out that way. So here we have ways for you to write your own diagnostic messages which are safer than just <code>print STDERR</code>.</p>
<ul>
<li><p class="startli"><b>diag</b> </p><pre class="fragment">  diag(diagnostic_message...);
</pre><p class="startli">Prints a diagnostic message which is guaranteed not to interfere with test output. The arguments are simply concatenated together.</p>
<p class="startli">Returns false, so as to preserve failure.</p>
<p class="startli">Handy for this sort of thing: </p><pre class="fragment">ok( has_user("foo"), "There's a foo user" ) or
    diag("Since there's no foo, check that /etc/bar is set up right");
</pre><p class="startli">which would produce: </p><pre class="fragment">not ok 42 - There's a foo user
#   Failed test 'There's a foo user'
# Since there's no foo, check that /etc/bar is set up right.
</pre><p class="startli">You might remember <code><a class="el" href="tap_09_09_8h.html#a2cc8d7b84f20225ecaa111bd1c7f584c" title="primary testing function. uses &#39;condition&#39; to determine  state of the test, which is described by arg...">ok()</a> or <a class="el" href="tap_09_09_8h.html#a1022766399fda6cf85773ab66382b840" title="print diagnostic message to error stream ">diag()</a></code> with the mnemonic <code>open() or die()</code>.</p>
<p class="startli"><b>NOTE</b> The exact formatting of the diagnostic output is still changing, but it is guaranteed that whatever you throw at it it won't interfere with the test.</p>
</li>
<li><p class="startli"><b>note</b> </p><pre class="fragment">  note(diagnostic_message...);
</pre><p class="startli">Like <a class="el" href="tap_09_09_8h.html#a1022766399fda6cf85773ab66382b840" title="print diagnostic message to error stream ">diag()</a>, except the message will not be seen when the test is run in a harness. It will only be visible in the verbose TAP stream.</p>
<p class="startli">Handy for putting in notes which might be useful for debugging, but don't indicate a problem. </p><pre class="fragment">note("Tempfile is ", tempfile);
</pre><p class="startli"><code>diag</code> simply catenates its arguments to the error output, while <code>note</code> prints diagnostics to the TAP stream.</p>
</li>
<li><b>set_output()</b></li>
<li><p class="startli"><b>set_error()</b> </p><pre class="fragment">  void set_output(std::ofstream&amp; new_output);
  void set_error(std::ofstream&amp; new_error);
</pre><p class="startli">These set the filehandle of the TAP stream and the error stream. They default to <code>std::cout</code> and <code>std::cerr</code>, respectively. These can only be set before any output is written to them.</p>
</li>
</ul>
<h2>Ending a test run</h2>
<ul>
<li><p class="startli"><b><a class="el" href="tap_09_09_8cpp.html#aa7098642671baec3200c8bb486552aee" title="return the number of tests failed or 255, whichever is smaller ">exit_status()</a></b></p>
<p class="startli">If all your tests passed, Test::Builder will exit with zero (which is normal). If anything failed it will exit with how many failed. If you run less (or more) tests than you planned, the missing (or extras) will be considered failures. If the test died, even after having successfully completed all its tests, it will still be considered a failure and will exit with 255.</p>
<p class="startli">So the exit codes are... </p><pre class="fragment">0                   all tests successful
255                 test died or all passed but wrong # of tests run
any other number    how many failed (including missing or extras)
</pre><p class="startli">If you fail more than 254 tests, it will be reported as 254.</p>
</li>
<li><p class="startli"><b>bail_out()</b> </p><pre class="fragment">  int exit_status();
  void bail_out(const std::string&amp; reason);
</pre><p class="startli"><b>bail_out</b> terminates the current test program with exit code 255, indicating to the test harness that all subsequent testing should halt. Typically this is used to indicate that testing cannot continue at all.</p>
</li>
</ul>
<h1>SEE ALSO</h1>
<p><a href="http://www.testanything.org">http://www.testanything.org</a></p>
<p><a href="https://metacpan.org/pod/Test::More">Test::More</a> and <a href="http://man.he.net/man1/prove">prove(1)</a> are the traditional perl client library and TAP harness, respectively. This library is modeled after Test::More.</p>
<h1>AUTHORS</h1>
<p>Leon Timmermans wrote <code>libtap++</code>. He stole much of this documentation from Test::More. Mike Pomraning also contributed this documentation.</p>
<h1>COPYRIGHT</h1>
<p>Copyright (c) 2008, 2009, 2010 Leon Timmermans.</p>
<p>See the LICENSE file for details. </p>
</div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.11
</small></address>
</body>
</html>
